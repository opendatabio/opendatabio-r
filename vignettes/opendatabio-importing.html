<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="A. Chalom &amp; A. Vicentini" />

<meta name="date" content="2021-04-13" />

<title>Importing data using the OpenDataBio R client</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>
<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>






<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Importing data using the OpenDataBio R client</h1>
<h4 class="author">A. Chalom &amp; A. Vicentini</h4>
<h4 class="date">2021-04-13</h4>



<div id="importing-data-using-the-opendatabio-r-client" class="section level1">
<h1>Importing data using the OpenDataBio R client</h1>
<p>The <code>opendatabio</code> R package was created to allow data from an OpenDataBio server to be read, and to allow data to be easily imported to an OpenDataBio server. This vignette focus on data imports.</p>
</div>
<div id="setting-up-the-connection" class="section level1">
<h1>Setting up the connection</h1>
<p>The first thing to do when starting the data import is to correctly set up the connection to the OpenDataBio server using the <code>odb_config()</code> function or using the shell environment configuration.</p>
<p>See the “opendatabio-reading” vignette for details on how to use it.</p>
<pre><code>cfg = odb_config(base_url = &quot;http://opendatabio.ib.usp.br/opendatabio/api&quot;,token=&quot;YourToken&quot;)</code></pre>
</div>
<div id="opendatabio-import-functions" class="section level1">
<h1>OpenDataBio import functions</h1>
<p>All import functions have the same signature: the first argument is a <code>data.frame</code> with data to be imported, and the second parameter is a configuration object (generated by <code>odb_config</code>).</p>
<p>When writing an import request, check the <a href="https://github.com/opendatabio/opendatabio/wiki/API-v0-endpoints">OpenDataBio API endpoints documentation</a> in order to understand which columns can be declared in the <code>data.frame</code>.</p>
<p>All import functions return a job id, which can be used to check if the job is still running, if it ended with success or if it encountered an error. This job id can be used in the functions <code>odb_get_jobs()</code>, <code>odb_get_affected_ids()</code> and <code>odb_get_log()</code>, to find details about the job, which (if any) were the IDs of the successfully imported objects, and the full log of the job.</p>
<p><strong>Order is Important</strong> - correctly importing data may depend on already registered records. For example, importing an Individual with a Taxon identity requires the taxon name registered in the database, so you would first validate your taxon list and then import the Individual records.</p>
<pre><code>odb_import_persons(data, cfg)
Sending ODB request (filesize = 1856)
    id    created_at (...) Status
    127   2018-03-07 (...) Submitted
odb_get_affected_ids(127, cfg)
[1] 41 42
odb_get_log(127, cfg)
[1] &quot;WARNING: There is another registry of a person with name like João da Silva or abbreviation like SILVA, J.&quot;</code></pre>
</div>
<div id="importing-locations" class="section level1">
<h1>Importing locations</h1>
<p>Working with spatial data is a very delicate area, so we have attempted to make the workflow for inserting locations as easy as possible. You should use the web interface for large uploads, which will handle better memory issues.</p>
<p>If you want to upload administrative boundaries for a country, you may also just download a <a href="https://geojson.org/">geojson</a> file from <a href="https://osm-boundaries.com/">OSM-Boundaries</a> and upload it through the web interface directly.</p>
<p>Locations may be POLYGONS (POLYGON OR MULTIPOLYGON), POINTS (latitude and longitude) or PLOTS. Importation is straightforward, but the main issues to keep in mind:</p>
<ol style="list-style-type: decimal">
<li>Locations are hierarchical, so a location MUST lie completely within its parent location. If a children polygon does not lie completely within its informed parent, OpenDataBio will fail to recognize the parent. This may happen, for example, when importing imprecise administrative boundaries from <a href="http://gadm.org" class="uri">http://gadm.org</a>, or mixing GADM data with administrative polygons from other sources. Adding a small buffer to the parent, downloading a different source or fixing the boundaries are possible solutions if you encounter these problems. Alternatively, you may just pass ‘parent=0’, and the location will be placed without a parent (in locations root, or World);</li>
<li>Consider, uploading your political administrative polygons before adding specific POINT or polygon locations;</li>
<li>Conservation Units are treated as special case by OpenDataBio, as some UCs may span different administrative locations. So a Location may belong to a UC in addition to its parent location. Therefore, UCs (adm_level==99) my be used to store any territorial area that transcends country administrative boundaries, and so are also usefull to store Indigenous Territories;</li>
<li>OpenDataBio stores the geometries of locations using Well-known text (WKT) representation.</li>
</ol>
<div id="adm_level-defines-the-hierarchy" class="section level2">
<h2>Adm_level defines the hierarchy</h2>
<p>Location data are hierarchical and you should consider to seed your database with administrative polygons prior to enter POINT or PLOT locations. The administrative level (adm_level) of a location is a number:</p>
<ul>
<li>2 for country; 3 to 10 as other as ‘administrative areas’, following <a href="https://wiki.openstreetmap.org/wiki/Tag:boundary%3Dadministrative#10_admin_level_values_for_specific_countries">OpenStreeMap convention</a> to facilitate external data importation and local translations (TO BE IMPLEMENTED). So, for Brazil, codes are (States=4, Municipalities=8);</li>
<li>100 is the code for plots and subplots;</li>
<li>999 for ‘POINT’ locations like GPS waypoints;</li>
<li>99 is the code for Conservation Units or Indigenous Territories;</li>
<li>101 for transects</li>
</ul>
</div>
<div id="importing-spatial-polygons" class="section level2">
<h2>Importing spatial polygons</h2>
<div id="administrative-boundaries-from-gadm" class="section level3">
<h3>Administrative boundaries from GADM</h3>
<p>To import administrative boundaries, which are POLYGONS, you may download the needed areas from GADM and easily import them into OpenDataBio:</p>
<pre><code>library(raster)
library(opendatabio)
#download GADM administrative areas for a country

#get country codes
crtcodes = getData(&#39;ISO3&#39;)
bra = crtcodes[crtcodes$NAME%in%&quot;Brazil&quot;,]

#define a path where to save the downloaded spatial data
path = &quot;GADMS&quot;
dir.create(path,showWarnings = F)

#the number of admin_levels in each country varies
#get all levels that exists into your computer
runit =T
level = 0
while(runit) {
   ocrt &lt;- try(getData(&#39;GADM&#39;, country=bra, level=level,path=path),silent=T)
   if (class(ocrt)==&quot;try-error&quot;) {
      runit = FALSE
   }
   level = level+1
}

#read downloaded data and format to odb
files = list.files(path, full.name=T)
locations.to.odb = NULL
for(f in 1:length(files)) {
   ocrt &lt;- readRDS(files[f])
   #class(ocrt)
   #convert the SpatialPolygonsDataFrame to OpenDataBio format
   ocrt.odb = opendatabio:::sp_to_df(ocrt)  #only for GADM data
   locations.to.odb = rbind(locations.to.odb,ocrt.odb)
}
#see without geometry
head(locations.to.odb[,-ncol(locations.to.odb)])

#you may add a note to location
locations.to.odb$notes = paste(&quot;Source gdam.org via raster::get_data()&quot;,Sys.Date())

odb_import_locations(data=locations.to.odb,odb_cfg=cfg)

#ATTENTION: you may want to check for uniqueness of name+parent rather than just name, as name+parent are unique for locations. You may not save two locations with the same name within the same parent.
</code></pre>
</div>
<div id="a-shapefile-example" class="section level3">
<h3>A ShapeFile example</h3>
<pre><code>library(rgdal)

#read your shape file
path = &#39;mymaps&#39;
file = &#39;myshapefile.shp&#39;
layer = gsub(&quot;.shp&quot;,&quot;&quot;,file,ignore.case=TRUE)
data = readOGR(dsn=path, layer= layer)

#you may want to reproject the geometry to standard of your system
data = spTransform(data,CRS=CRS(&quot;+proj=longlat +datum=WGS84&quot;))

#convert polygons to WKT geometry representation
library(rgeos)  
geom = writeWKT(data,byid=TRUE)

#prep import
names = data@data$name  #or the column name of the data
shape.to.odb = data.frame(name=names,datum=&#39;WSG84&#39;,geom=geom,stringsAsFactors = F)

#need to add the admin_level of these locations
shape.to.odb$admin_level = 2

#and may add parent and note if your want
odb_import_locations(data=shape.to.odb,odb_cfg=cfg)
</code></pre>
</div>
<div id="converting-data-from-kml" class="section level3">
<h3>Converting data from KML</h3>
<pre><code>#read file as SpatialPolygonDataFrame
file = &quot;myfile.kml&quot;
file.exists(file)
mykml = readOGR(file)
geom = writeWKT(mykml,byid=TRUE)

#prep import
names = mykml@data$name  #or the column name of the data
to.odb = data.frame(name=names,datum=&#39;WSG84&#39;,geom=geom,stringsAsFactors = F)

#need to add the admin_level of these locations
to.odb$admin_level = 2

#and may add parent or any other valid field

#import
odb_import_locations(data=to.odb,odb_cfg=cfg)
</code></pre>
</div>
</div>
<div id="import-plots-and-subplots" class="section level2">
<h2>Import Plots and subplots</h2>
<p>Plots are a special case within OpenDataBio. They may have a geometry defined as any other location type, but may also have cartesian dimensions (X and Y) in meters. Subplots are plots within plot locations and may also have cartesian positions (startX, startY) within parent location in addition to dimensions. Cartesian position refer to X and Y positions within parent plot and hence MUST be smaller than parent X and Y. And the same is true for Individuals within plots or subplots when they have their own X and Y cartesian coordinates.</p>
<p>You need at least a single point geographical coordinate for a plot or subplot location. Geometry (or lat and long) cannot be empty. However, it may prevent you from placing a subplot within a plot if both are point locations. Hence, you should consider adding geometry as a polygon at least for plots when having subplots.</p>
<pre><code>#import a 1ha plot with automatic parent location

#geometry of plot in Manaus
lats = c( -3.095764,  -3.094822, -3.094822,-3.095764)
longs = c(-59.987747, -59.987747, -59.986835,-59.986835)
geom = cbind(longs,lats)
geom = Polygon(geom)
geom = Polygons(list(geom), ID = 1)
geom = SpatialPolygons(list(geom))
geom = writeWKT(geom)
plot.to.odb = data.frame(name=&#39;My plot&#39;,x=100,y=100,notes=&#39;a fake plot&#39;,geom=geom, adm_level = 100,stringsAsFactors=F)
odb_import_locations(data=plot.to.odb,odb_cfg=cfg)

#import a 20x20m subplot to the plot above with cartesian coordinates and a point geometry
latitude = -3.095442
longitude= -59.987657
subplot.to.odb = data.frame(name=&#39;My subplot&#39;,x=20,y=20,lat=latitude, long=longitude, adm_level=100,startx=0,starty=20,stringsAsFactors=F)

#import
odb_import_locations(data=subplot.to.odb,odb_cfg=cfg)</code></pre>
</div>
<div id="importing-latitude-longitude-data" class="section level2">
<h2>Importing latitude / longitude data</h2>
<p>The most straightforward way to import spatial data is importing the latitude and longitude of a point. You must convert the data to decimal representation, with positive values for North and East, and negative values for South and West. For instance, a point in Brasilia (Brazil) would have latitude of -15.64 and longitude of -46.87. The required fields to import locations are name, adm_level and either a latitude and longitude coordinate or a full <code>geom</code> object. You may specify a parent location for each object to speed up the process, but if you don’t, it will be detected automatically. Other fields may also be imported, check the API documentation for more details.</p>
<p>To import some points to the database, you can write</p>
<pre><code>lat = c(-9.9482, -7.2526, -12.3749)
long = c(-48.6371, -54.1272, -65.1819)
name = paste(&quot;GPS point&quot;, 1:3)
loclist = data.frame(name=name, lat=lat, long=long, adm_level = 999)
odb_import_locations(loclist, cfg)</code></pre>
</div>
</div>
<div id="importing-persons" class="section level1">
<h1>Importing persons</h1>
<p>It is recommended you use the web interface, as it will warn you in case the person you want to register has a similar, likely the same, person already registered. The API will only check for identical Abbreviations, which is the single restriction of the Person class. Abbreviations are unique and duplication are not allowed. This does not prevent data downloaded from repositories to have different abbreviations or full name for the same person. So, you should standardize secondary data before importing into the server to minimize such common errors.</p>
<pre><code>to.odb = data.frame(full_name=&#39;Adolpho Ducke&#39;,abbreviation=&#39;DUCKE, A.&#39;,notes=&#39;Grande botânico da Amazônia&#39;,stringsAsFactors = F)
odb_import_persons(to.odb,odb_cfg=cfg)

#may also add an email entry if you have one
</code></pre>
</div>
<div id="importing-taxons" class="section level1">
<h1>Importing taxons</h1>
<p>You can import a list of taxons using the <code>odb_import_taxons</code> function. For a successful importation of published names, you just need to provide a ‘name’ value, being the fullname for species and infraspecies categories (e.g. Licaria guianensis guianensis). You may also provide, ‘level’ and ‘parent’ to minimize assignment errors. The import process will use the “name” value to retrieve taxon info from a nomenclatural repository: Tropicos (Mobot), the International Plant Name Index (IPNI), Zoobank, Mycobank and GBIF. If found, it will automatically get the author, which is mandatory, and will detect the parent for the taxon. If the parent is not registered the importation will fail. If parent is informed and different from the one detected, then the informed parent may be used. For unpublished names, a <code>person</code> or <code>author_id</code> value must be provided.</p>
<p>Therefore, if you are trying to import a large number of published taxon names, should first check that parents are registered and import them first, but the API will tell you what is missing. Spelling errors in names my, therefore, prevent a taxon from being stored. When receiving a list of published taxonomic names at any level, it is often necessary to clean up typographical errors, capitalization, and other incorrect names. The package <code>taxize</code> can help with that, and may also help you get valid parent names for all Taxon levels, in case they are also not stored in your system.</p>
<p>Taxonomy is hierarchical and the structure within the OpenDataBio may be treelike. So, you may add, if you want, any node from the tree of life into the Taxon table. For these you need to use the <code>Clade</code> taxon level. But note, this may not be relevant if you are not going link data to such clade name.</p>
<p>Unpublished names for species may also be recorded, but they require an author, which is a Person in the database.</p>
<div id="simple-example" class="section level2">
<h2>Simple example</h2>
<p>Check your name with taxize:</p>
<pre><code>spp = c(&quot;Ficus Schultesii&quot;, &quot;Ficus catingae&quot;, &quot;Ficus caballina&quot;)
checked.spp = taxize::gnr_resolve(spp, canonical=TRUE, best_match_only=TRUE)[, c(1,5)]
checked.spp = as.data.frame(fixed,stringsAsFactor=F)
checked.spp
</code></pre>
<p>After the species list is cleaned up, it may be transformed into a <code>data.table</code> and imported:</p>
<pre><code>spp = checked.spp$matched_name2
splist = data.frame(name=spp, level=&quot;species&quot;, parent_name=&quot;Ficus&quot;)
odb_import_taxons(splist, cfg)</code></pre>
<p>For species and infraspecific categories parent_name must be provided, either as name or as a numeric id value that you may get with <code>odb_get_taxons</code>.</p>
</div>
<div id="taxon-and-parents-from-tropicos-mobot" class="section level2">
<h2>Taxon and parents from Tropicos (MOBOT)</h2>
<p>Import a Taxon and the full parent classification, retrieving data from Tropicos. The example also uploads the mobotid, the taxon publication reference and author, when available. Not that Tropicos classification for upper taxonomic levels may be outdated from current APG system.</p>
<pre><code>#get taxon data from tropicos
tx = taxize::tp_search(&quot;Lauraceae&quot;,db=&#39;tropicos&#39;)
tx = as.data.frame(tx)

#get full classification hierarchy if not already in ODB
tx.class = taxize::classification(tx$nameid,db=&quot;tropicos&quot;)
tx.class = tx.class[[1]]

#helper to use taxize with apply
mytp_search &lt;- function(x) {
    as.data.frame(taxize::tp_search(nameid=x,db=&#39;tropicos&#39;),stringsAsFactors=F)
}
tx.class = lapply(tx.class$id,mytp_search)
tx.class = do.call(rbind,tx.class)

#join and get relevant columns
cls = c(&quot;nameid&quot;, &quot;scientificname&quot;, &quot;author&quot;, &quot;displayreference&quot;,&quot;rankabbreviation&quot;)
tx.to.odb = rbind(tx.class[,cls],tx[,cls])
colnames(tx.to.odb ) = c(&quot;mobot&quot;,&quot;name&quot;,&quot;author&quot;,&quot;bibreference&quot;,&quot;level&quot;)

#get taxon levels as numeric values from ODB
codes = odb_taxonLevelCodes(level=tx.to.odb$adm_level)
sum(is.na(codes)) #all found
tx.to.odb$level = codes

#order your table following the hierarchy as you need to import parent before children
tx.to.odb = tx.to.odb[order(tx.to.odb$level),]

#add parents. Here, each line is a parent of the following and the first must be attached somewhere in the Taxon table
rootparent.name = &quot;Spermatopsida&quot;  #or whatever taxon already in data.base to assign the first as children
parents = c(rootparent.name,tx.to.odb$name[1:(nrow(tx.to.odb)-1)])
tx.to.odb$parent_name = parents

#import
odb_import_taxons(tx.to.odb,odb_cfg=cfg)
</code></pre>
</div>
<div id="an-unpublished-species-or-morphotype" class="section level2">
<h2>An unpublished species or morphotype</h2>
<p>It is common to have unpublished local species names (morphotypes) for plants in plots, or yet to be published taxonomic work. Unpublished designation are project specific and therefore MUST also provide an author as different projects may use the same ‘sp.1’ or ‘sp.A’ code for their unpublished taxons.</p>
<p>You may link an unpublished name as any taxon level and do not need to use Genus+species logic to assign a morphotype for which the genus or upper level taxonomy is undefined. For example, you may store a ‘species’ level with name ‘Indet sp.1’ and parent_name ‘Laurales’, if the lowest level formal determination you have is the order level. In this example, there is no need to store a Indet genus and Indet family taxons just to account for this unidentified morphotype.</p>
<pre><code>#assign an unpublished name for which you only know belongs to the Angiosperms and you have this node in the Taxon table already
#check that angiosperms exist 
odb_get_taxons(params=list(name=&#39;Angiosperms&#39;),odb_cfg = cfg)

to.odb = data.frame(name=&#39;Morphotype sp.1&#39;, parent_name=&#39;Angiosperms&#39;, stringsAsFactors=F)

#get species level code
to.odb$level=odb_taxonLevelCodes(&#39;sp.&#39;)

#you must provide an author that is a Person in the Person table. Get from server
odb.persons = odb_get_persons(params=list(search=&#39;name.to.search.here&#39;),odb_cfg=cfg)

#found
head(odb.persons)

#add
to.odb$author = odb.persons$id

#import
odb_import_taxons(to.odb,odb_cfg = cfg)
</code></pre>
</div>
<div id="import-a-published-clade" class="section level2">
<h2>Import a published clade</h2>
<p>You may add a clade Taxon and may reference its publication using the <code>bibkey</code> entry. So, it is possible to actually store all relevant nodes of any phylogeny in the Taxon hierarchy.</p>
<pre><code>#parent must be stored already
odb_get_taxons(params=list(name=&#39;Pagamea&#39;),odb_cfg = cfg)

#define clade Taxon
to.odb = data.frame(name=&#39;Guianensis core&#39;, parent_name=&#39;Pagamea&#39;, stringsAsFactors=F)
to.odb$level = odb_taxonLevelCodes(&#39;clade&#39;)

#add a reference to the publication where it is published 
#import bib reference to database beforehand
odb_get_bibreferences(params(bibkey=&#39;prataetal2018&#39;),odb_cfg=cfg)
to.odb$bibkey = &#39;prataetal2018&#39;

#then add valid species names as children of this clade instead of the genus level
children = data.frame(name = c(&#39;Pagamea guianensis&#39;,&#39;Pagamea angustifolia&#39;,&#39;Pagamea puberula&#39;),stringsAsFactors=F)
children$parent_name = &#39;Guianensis core&#39;
children$level = odb_taxonLevelCodes(&#39;species&#39;)
children$bibkey = NA

#merge
to.odb = rbind(to.odb,children)

#import
odb_import_taxons(to.odb,odb_cfg = cfg)
</code></pre>
</div>
</div>
<div id="working-with-dates-and-incomplete-dates" class="section level1">
<h1>Working with dates and incomplete dates</h1>
<p>For individuals, vouchers and identifications you may use incomplete dates.</p>
<p>The date format used in OpenDataBio is year - month - day, so a valid entry would be ‘2018-05-28’. In many older collections, the exact day (or month) is not known, so you can substitute this fields with NA: ‘1979-05-NA’ means “an unknown day, in May 1979”, and ‘1979-NA-NA’ means “unknown day and month, 1979”. You may not add a date for which you have only the day, but can if you have only the month if is actually meaningful in some way.</p>
</div>
<div id="importing-individuals" class="section level1">
<h1>Importing Individuals</h1>
<p>Individuals can be imported using <code>odb_import_individuals()</code>. Individuals must have an unique identifier defined by the combination of Tag+Collector+Location, which defines the individuals fullname.</p>
<div id="mandatory-fields" class="section level2">
<h2>Mandatory fields</h2>
<ol style="list-style-type: decimal">
<li>tag = the number for the record, may be the aluminium tag on tree or bird ring, or the <code>collector number</code> of an herbarium specimen;</li>
<li>collectors = persons ids, abbreviations, full_names or emails, as a string separated by ‘;’ or ‘|’, or list. Get ids with <code>odb_get_persons()</code>. The first person on the list is the <code>main collector</code></li>
<li>date = complete or incomplete collecting date for the individual (see above). You may inform as separate fields: date_year, date_month, date_day, or just year,month, day;</li>
<li>project = the project_id or name to which the individual will be linked and which you may get with <code>odb_get_projects()</code>.</li>
</ol>
</div>
<div id="individual-location-fields" class="section level2">
<h2>Individual location fields</h2>
<p><strong>Mandatory</strong> 1. location = id, or name of registered location OR 1. latitude and longitude = coordinates of record (will save a POINT location if it does not exists) <strong>Optional</strong> 1. altitude = in meters above sea level; 1. location_notes = text; 1. location_date_time = complete date time string: YYYY-MM-DD HH:mm:ss 1. x = cartesian position within location (for PLOT type) 1. y = cartesian position within location (for PLOT type) 1. distance = distance in meters from location (for POINT type) 1. angle = azimuth in degrees from location (for POINT type)</p>
</div>
<div id="individual-identification-fields-optional" class="section level2">
<h2>Individual identification fields (optional)</h2>
<p>An Individual may have its own taxonomic identification (self) or may be linked to another individual that has an identification (non-self)</p>
<p><strong>For non-self identifications</strong>: 1. identification_individual = the id or full name of the Individual having the Identification - get with <code>odb_get_individuals()</code>;</p>
<p><strong>For self identifications</strong>: 1. taxon = the taxon id or name - get with <code>odb_get_taxons()</code>. 1. identifier = the person ‘id’, ‘abbreviation’, ‘full_name’, ‘email’ that made the identification. get with <code>odb_get_persons()</code>. 1. identification_date = complete or incomplete date, as string or name list (see above) 1. modifier = if you need a modifier, use the numerical codes from <code>odb_detModifiers()</code>. Optional. Defaults to 0, ‘none’. 1. identification_notes = Optional, a text referring to the identification. 1. identification_based_on_biocollection = Optional, when the identification comes from a comparison with an herbarium specimen, you may add here the acronym or id of the Biocollection, and the id number 1. identification_based_on_biocollection_id = Optional. The Biocollection id or reference code.</p>
<p>The last two fields allow you to link your identification to a specimen in a BioCollection and may be used to retrieve updates for the identification of the individual in your database. For this to be meaningful, <code>identification_based_on_biocollection_id</code> must be a somewhat permanent code that allows you to find it in the herbarium data repository(or GBIF, SpeciesLink, etc) in the future.</p>
<div id="individual-vouchers-optional" class="section level3">
<h3>Individual vouchers (optional)</h3>
<p>If Individual has Vouchers you may import them along with the Individual record by adding the biocollection fields listed below. This is <strong>valid only if Voucher has the same collector and number (i.e. tag) as that of the Individual</strong> (else import them after importing Individuals with <code>odb_import_vouchers()</code>). 1. biocollection = string of ids or acronyms separated by ‘;’ or ‘|’; 1. biocollection_number = string of local biocollection repository ids separated by ‘;’ or ‘|’, same length as ‘biocollection’ 1. biocollection_type = string of numerical nomeclatural type codes separated by ‘;’ or ‘|’, same length as ‘biocollection’. You may get the code list with <code>odb_nomenclaturalTypes()</code>; defaults to 0, not type.</p>
<p>You may also specify these as a list or data.frame in the ‘biocollection’ column, having three columns/elements:‘biocollection_code’,‘biocollection_number’,‘biocollection_type’.</p>
</div>
<div id="individual-example" class="section level3">
<h3>Individual example</h3>
<pre><code>basic.fields =  c(&quot;tag&quot;, &quot;location&quot;, &quot;collector&quot;,&quot;relative_position&quot;,&quot;date&quot;)
identification.fields = c(&quot;taxon&quot;, &quot;identifier&quot;, &quot;modifier&quot;, &quot;identification_date&quot;,&quot;identification_notes&quot;, &quot;identification_based_on_biocollection&quot;,&quot;identification_based_on_biocollection_id&quot;)

#register a plant in a forest plot location
#the number in the aluminium tag in the forest
to.odb = data.frame(tag=&#39;3405.L1&#39;, stringsAsFactors=F)

#the collectors (get ids from the server)
joao = odb_get_persons(params=list(search=&#39;joao batista&#39;),odb_cfg=cfg)$id
ana = odb_get_persons(params=list(search=&#39;ana andrade&#39;),odb_cfg=cfg)$id
#ids concatenated by | pipe 
to.odb$collector = paste(joao,ana,sep=&#39;|&#39;)

#tagged date (lets use an incomplete).
to.odb$date = &#39;2018-07-NA&#39;

#lets place in a Plot location
to.odb$location = odb_get_locations(params=list(name=&#39;Plot 2021&#39;),odb_cfg=cfg)$id

#relative position within parent 
to.odb$x = 10.4
to.odb$y = 32.5
#or could be
to.odb$relative_position = paste(x,y,sep=&#39;,&#39;)

#taxonomic identification
  #check that exists
  taxon = odb_get_taxons(params=list(name=&#39;Dinizia excelsa&#39;),odb_cfg=cfg)$id
    # OR if you are sure it exists you could just
    taxon = &#39;Dinizia excelsa&#39;
    
  #person that identified the individual
  to.odb$identifier = odb_get_persons(params=list(search=&#39;paulo apostolo&#39;),odb_cfg=cfg)$id
  
  #may add modifers as well [may need to use numeric code instead]
  to.odb$modifier = &#39;cf.&#39;  
    #or check with odb_detModifiers() to see you spelling is correct 
    #to be safe use number code
    to.odb$modifier = 3

  #an incomplete identification date
  to.odb$identification_date = list(year=2005) 
    #or  to.odb$identification_date =  &quot;2005-NA-NA&quot;

odb_import_individuals(to.odb,odb_cfg = cfg)
</code></pre>
</div>
<div id="an-even-simpler-example" class="section level3">
<h3>An even simpler example</h3>
<p>You may just use the code below, but will imply the following assumptions as identifications cannot be added without identifier nor identification_date: a) identifier will be the default Person associated with your profile; b) identification_date will be the same as date.</p>
<pre><code>location = c(&quot;GPS point 2&quot;, &quot;GPS point 1&quot;)
tag = c(&quot;001&quot;,&quot;002&quot;)
date = c(&quot;2017-08-09&quot;, &quot;2017-05-NA&quot;)
taxon = c(&quot;Abarema acreana&quot;, &quot;Aciotis olivieriana&quot;)
plantlist = data.frame(location=location, tag=tag, date=date, taxon=taxon, project=&quot;Rare species of the Para region&quot;)
odb_import_individuals(plantlist, cfg)
</code></pre>
</div>
</div>
</div>
<div id="import-vouchers" class="section level1">
<h1>Import Vouchers</h1>
<p>Vouchers are samples of Individuals deposited in BioCollections. If the Biocollection is a genetic resource, the Voucher may just represent a DNA or tissue sample.</p>
<p>Therefore, Vouchers must belong to an Individual and to a BioCollection, which are the mandatory information to register vouchers. Collectors, collection date, location and taxonomic identity are just extracted from the Individual’s record. But a Voucher may have its own collector, collector number and collecting date, different from the Individual it belongs to.</p>
<div id="mandatory" class="section level2">
<h2>Mandatory</h2>
<ol style="list-style-type: decimal">
<li>individual = individual id or full name;</li>
<li>biocollection = acronym or id of the BioCollection - use <code>odb_get_biocollections()</code> to check if register;</li>
</ol>
</div>
<div id="optional" class="section level2">
<h2>Optional</h2>
<ol style="list-style-type: decimal">
<li>biocollection_number = string of local reference codes separated by ‘;’ or ‘|’, same length as ‘biocollection’</li>
<li>biocollection_type = string of numerical nomeclatural type codes separated by ‘;’ or ‘|’, same length as ‘biocollection’. Get codes with <code>odb_nomenclaturalTypes()</code></li>
<li>collector = list of ids, abbreviations, full_names or emails of persons, separated by ‘;’ or ‘|’; to get a list use <code>odb_get_persons()</code>; IF DIFFERENT FROM Individual’s collector</li>
<li>number = the collector-number code; IF DIFFERENT FROM Individual’s Tag</li>
<li>date = complete or incomplete date for the Voucher collection IF DIFFERENT FROM Individual’s date</li>
<li>notes = any text you wish;</li>
</ol>
</div>
</div>
<div id="import-traits" class="section level1">
<h1>Import Traits</h1>
<p>Before importing any trait, make sure the variable is not already registered in the system with a different name. Preventing duplication is important as the Trait class is shared among all users of an OpenDataBio installation. This also means that once a trait is used for Measurements, you may only alter the trait’s definition, for example, a category name, if you were the only user entering the measurements. Otherwise, somebody else used that definition and you will not be able to alter it.</p>
<p>Traits have one restriction: <strong>export_name must be unique</strong> in a single ODB installation. This name is used as a column name when exporting data and you should consider making it as short and informative (of definition) as possible. Also, try not to add spaces or any special character (accents) in export names. We recommend you use ‘camelCase’ or ‘PascalCase’ or ‘snake_case’, such as ‘leafLength’, ‘LeafLength’ or ‘leaf_length’.</p>
<div id="traits-entries" class="section level2">
<h2>Traits entries</h2>
<p>See <code>odb_traitTypeCodes()</code> for possible trait types.</p>
</div>
<div id="mandatory-1" class="section level2">
<h2>Mandatory</h2>
<ol style="list-style-type: decimal">
<li>export_name - string (see note above)</li>
<li>name - string for English (first language in database table), or a list for all languages, having the keys as the Language ids. Get languages from server using <code>odb_get_languages()</code>.</li>
<li>description - like name, but for a detailed trait definition in multiple languages;</li>
<li>type - a 0 to 8 numeric code. Check <code>odb_traitTypeCodes()</code>;</li>
<li>objects - string containing which core-objects the trait may be used for. Possible values are ‘Individual’, ‘Voucher’, ‘Location’ and/or ‘Taxon’, singular and case sensitive.</li>
</ol>
</div>
<div id="trait-specific-or-optional" class="section level2">
<h2>Trait specific or optional</h2>
<ol style="list-style-type: decimal">
<li>units - required for quantitative traits only (the unit o measurement), standard to English</li>
<li>range_min - optional for quantitative (minimum value to be accepted)</li>
<li>range_max - optional for quantitative (maximum value the trait may recieve)</li>
<li>categories - required for categorical; data.frame with categories translations;</li>
<li>bibkey - optional, bibkey to link trait definition with reference in database</li>
<li>wavenumber_min - required for spectral traits (may be informed as range_min)</li>
<li>wavenumber_max - required for spectral traits (may be informed as range_max)</li>
<li>value_length - required for spectral traits = number of values in spectrum</li>
<li>link_type- required for Link traits - the class of link type, fullname or basename: eg. ‘Taxon’ or ‘App’.</li>
</ol>
</div>
<div id="trait-name-and-categories-user-translations" class="section level2">
<h2>Trait name and categories User translations</h2>
<p>Fields <strong>name</strong> and <strong>description</strong> could be one of following: 1. using the Language code as keys: <code>list(&quot;en&quot; = &quot;Diameter at Breast Height&quot;,&quot;pt&quot; =&quot;Diâmetro a Altura do Peito&quot;)</code> 1. or using the Language ids as keys: <code>list(&quot;1&quot; = &quot;Diameter at Breast Height&quot;,&quot;2&quot; =&quot;Diâmetro a Altura do Peito&quot;}</code>. 1. or using the Language names as keys: <code>list(&quot;English&quot; =&quot;Diameter at Breast Height&quot;,&quot;Portuguese&quot; =&quot;Diâmetro a Altura do Peito&quot;)</code>. <br><br> Field <strong>categories</strong> must include for each category+rank+lang the following fields: 1. lang=mixed - required, the id, code or name of the language of the translation 1. name=string - required, the translated category name required (name+rank+lang must be unique) 1. rank=number - required, rank is important to indicate the same category across languages, and defines ordinal traits; 1. description=string - optional for categories, a definition of the category. This may be formatted as a data.frame and placed in the <code>categories</code> column of another data.frame:</p>
<pre><code>data.frame(
  rbind(
    c(&quot;lang&quot;=&quot;en&quot;,&quot;rank&quot;=1,&quot;name&quot;=&quot;small&quot;,&quot;description&quot;=&quot;smaller than 1 cm&quot;),
    c(&quot;lang&quot;=&quot;pt&quot;,&quot;rank&quot;=1,&quot;name&quot;=&quot;pequeno&quot;,&quot;description&quot;=&quot;menor que 1 cm&quot;),
    c(&quot;lang&quot;=&quot;en&quot;,&quot;rank&quot;=2,&quot;name&quot;=&quot;big&quot;,&quot;description&quot;=&quot;bigger than 10 cm&quot;),
    c(&quot;lang&quot;=&quot;pt&quot;,&quot;rank&quot;=2,&quot;name&quot;=&quot;grande&quot;,&quot;description&quot;=&quot;maior que 10 cm&quot;)
  ),
  stringsAsFactors=FALSE
)</code></pre>
</div>
<div id="quantitative-traits" class="section level2">
<h2>Quantitative traits</h2>
<p>For quantitative traits for either <em>integers</em> or <em>real</em> values (types 0 or 1).</p>
<pre><code>odb_traitTypeCodes()

#do this first to build a correct data.frame as it will include translations list
to.odb = data.frame(type=1,export_name = &quot;dbh&quot;, units=&#39;centimeters&#39;,stringsAsFactors = F)

#add translations (note double list) 
#format is language_id = translation (and the column be a list with the translation lists)
to.odb$name[[1]]= list(&#39;1&#39; = &#39;Diameter at breast height&#39;, &#39;2&#39; = &#39;Diâmetro à altura do peito&#39;)
to.odb$description[[1]]= list(&#39;1&#39; = &#39;Stem diameter measured at 1.3m height&#39;,&#39;2&#39; = &#39;Diâmetro do tronco medido à 1.3m de altura&#39;)

#measurement validations
to.odb$range_min = 10  #this will restrict the minimum measurement value allowed in the trait
to.odb$range_max = 400 #this will restrict the maximum value

#measurements can be linked to (classes concatenated by , or a list)
to.odb$object = &quot;Individual,Voucher,Taxon&quot;  #makes no sense link such measurements to Locations

to.odb$notes = &#39;a fake note&#39;

#import
odb_import_traits(to.odb,odb_cfg=cfg)
</code></pre>
</div>
<div id="categorical-or-ordinal-traits" class="section level2">
<h2>Categorical or ordinal traits</h2>
<p>Must include categories. The only difference between ordinal and categorical traits is that ordinal categories will have a rank and the rank will be inferred from the order the categories are informed during importation. Note that ordinal traits are semi-quantitative and so, if you have categories ask yourself whether they are not really ordinal and register accordingly.</p>
<p>Like the Trait name and description, categories may also have different language translations, and you SHOULD enter the translations for the languages available (<code>odb_get_languages()</code>) in the server, so the Trait will be accessible in all languages. English is mandatory, so at least the English name must be informed. Categories may have a description associated, but sometimes the category name is self explanatory, so descriptions of categories are not mandatory.</p>
<div id="multiselection-categories" class="section level3">
<h3>Multiselection categories</h3>
<pre><code>odb_traitTypeCodes()

#do this first to build a correct data.frame as it will include translations list
to.odb = data.frame(type=3,export_name = &quot;specimenFertility&quot;, stringsAsFactors = F)

#trait name and description
to.odb$name =  data.frame(&quot;1&quot;=&quot;Specimen Fertility&quot;,&quot;2&quot;=&quot;Fertilidade do especímene&quot;,stringsAsFactors=F)
to.odb$description =  data.frame(&quot;1&quot;=&quot;Kind of reproductive stage of a collected plant&quot;,&quot;2&quot;=&quot;Estágio reprodutivo de uma amostra de planta coletada&quot;,stringsAsFactors=F)

#categories (if your trait is ORDINAL, the add categories in the wanted order here)
categories = data.frame(
  rbind(
    c(&#39;eng&#39;,1,&quot;Sterile&quot;),
    c(&#39;pt&#39;,1,&quot;Estéril&quot;),
    c(&#39;eng&#39;,2,&quot;Flowers&quot;),
    c(&#39;pt&#39;,2,&quot;Flores&quot;),
    c(&#39;eng&#39;,3,&quot;Fruits&quot;),
    c(&#39;pt&#39;,3,&quot;Frutos&quot;),
    c(&#39;eng&#39;,4,&quot;Flower buds&quot;),
    c(&#39;pt&#39;,4,&quot;Botões florais&quot;)
  ),
  stringsAsFactors =FALSE
)
colnames(categories) = c(&quot;lang&quot;,&quot;rank&quot;,&quot;name&quot;)

#descriptions not included for categories as they are obvious, 
# but you may add a &#39;description&#39; column to the categories data.frame

#objects for which the trait may be used for
to.odb$object = &quot;Individual,Voucher&quot;  

to.odb$notes = &#39;a fake note&#39;

#import
odb_import_traits(to.odb,odb_cfg=cfg)</code></pre>
</div>
</div>
<div id="link-type-traits" class="section level2">
<h2>Link type traits</h2>
<p>Link types are traits that allow you link an Individual, Taxon or Voucher as a value measurement to another object. For example, you may conduct a plant inventory for which you have only counts for Taxon associated to a locality. Therefore, you may create a LINK trait, which will allow you to store the count values for any Taxon as measurements for a particular location (POINT, POLYGON). Or you may link such values to Vouchers instead of Taxons if you have a representative specimen for the taxons.</p>
<p>Use the WebInterface.</p>
</div>
<div id="text-and-color-traits" class="section level2">
<h2>Text and color traits</h2>
<p>Text and color traits require the minimum fields only for trait registration. Text traits allow the storage of textual observations. Color will only allow color codes (see under Measurements)</p>
<pre><code>odb_traitTypeCodes()

to.odb = data.frame(type=5,export_name = &quot;taxonDescription&quot;, stringsAsFactors = F)

#trait name and description
to.odb$name =  data.frame(&quot;1&quot;=&quot;Taxonomic descriptions&quot;,&quot;2&quot;=&quot;Descrições taxonômicas&quot;,stringsAsFactors=F)
to.odb$description =  data.frame(&quot;1&quot;=&quot;Taxonomic descriptions from the literature&quot;,&quot;2&quot;=&quot;Descrições taxonômicas da literatura&quot;,stringsAsFactors=F)

#will only be able to use this trait for a measurment associated with a Taxon
to.odb$object = &quot;Taxon&quot;

#import
odb_import_traits(to.odb,odb_cfg=cfg)
</code></pre>
</div>
<div id="spectral-traits" class="section level2">
<h2>Spectral traits</h2>
<p>Spectral traits are specific to spectral data. You must specify the range of wavenumber values for which you may have absorbance or reflectance data, and the length of the spectra to be stored as measurements to allow validation during input. So, for each range and spacement of the spectral values you have, a different SPECTRAL trait must be created.</p>
</div>
<div id="genebank-trait" class="section level2">
<h2>Genebank trait</h2>
<p>To be included in OpenDataBio - a link of a voucher or individual to a specific GeneBank accession. This will permit to link and ODB record to a genebank accession and therefore, to download molecular data from GeneBank and annotate it with the current ODB taxonomic identity.</p>
</div>
</div>
<div id="import-measurements" class="section level1">
<h1>Import Measurements</h1>
<p>Measurements are straightforward. You need to provide a dataset (for which you do have permissions), trait_id, value (content varies depending on trait type), date (a complete or incomplete date), person (id of person that measured), object_type (taxon, plant, voucher or location) and object_id. For LINK trait type, you must provide a link_id column, and ‘value’ becomes optional for this specific case.</p>
<p>Measurement have one restriction in the API: duplicated measurements values or categories for the same object_id and date will not be imported, unless you specify a ‘duplicated=1’ entry in the import table.</p>
<p>TIP: To link measurements in different traits you may add standard keys to the ‘note’ measurement field. For example, you measure LeafLength and LeafWidth from the same leaves, so in both cases add “leaf1” ,“leaf2”, .. to the note field. Also, you measure DBH and DBH.POM in a forest plot inventory and have several stems for a plant, you may add “stem1”,“stem2” to permit matching a stem DBH to its specific height of measurement. This kind of link may be useful in analyses.</p>
<p>Several validations will happen during measurement importation. Consider verifying the data locally before submitting a job to facilitate troubleshooting, and guarantee the values are consistent with your expectations. You will not be able to UPDATE nor DELETE measurements with the API, so, avoid importing several measurements that will require fixing afterwards (one by one).</p>
<div id="mandatory-columns" class="section level2">
<h2>Mandatory columns</h2>
<ol style="list-style-type: decimal">
<li>trait_id - the trait_id or export_name</li>
<li>value - depends on trait type (see examples) - optional for LINK trait type</li>
<li>date - the date the measurement was made (fundamental for monitoring)</li>
<li>object_type - one of c(“Plant”,“Voucher”,“Taxon”, “Location”) - must be in Trait definition</li>
<li>object_id - the id of the object</li>
<li>dataset - the name or id of the dataset to include the measurement (use id)</li>
<li>person - the id of the person (single person) that did measurement</li>
<li>bibreference - either a bibkey or a bib_id for a BibReference in the system</li>
<li>link_id - only for LINK_TYPE traits - must be the id to the type of LINK the trait refers to</li>
</ol>
</div>
<div id="optional-1" class="section level2">
<h2>Optional</h2>
<ol style="list-style-type: decimal">
<li>notes - any note you want, but see TIP above</li>
<li>duplicated - with value 1 to allow duplicated measurements in the same date for the same object and trait</li>
</ol>
</div>
<div id="quantitative-measurements" class="section level2">
<h2>Quantitative measurements</h2>
<p>OpenDataBio will not be able to test whether your measurements are in the same unit as the Trait definition. Therefore, check which unit the trait has, and convert accordingly before uploading your data.</p>
<pre><code>#get the trait id from the server (check that trait exists)
odbtraits = odb_get_traits(odb_cfg=cfg)
(m = match(c(&quot;dbh&quot;,&quot;dbhPom&quot;),odbtraits$export_name))
to.odb = data.frame(trait_id = odbtraits$id[m], value = c(24.5,1.3), date = &#39;2020-07-31&#39;, object_type = &#39;Individual&#39;, stringsAsFactors=F)

to.odb$notes = &quot;stem1΅ #both are from the same stem

#check MEASUREMENT UNIT for trait and make sure your data conform, otherwise convert
odbtraits$unit[m]

#get individual id from API
# must be ID not tag. If you add a numeric tag and there is an id matching the tag
# the measurement will be misplaced.
odbplant = odb_get_individuals(params=list(tag=&#39;1234&#39;),odb_cfg=cfg)
head(odbplant)
to.odb$object_id = odbplant$id

#get dataset id
odbdatasets = odb_get_datasets(params=list(name=&#39;Plot data&#39;),odb_cfg=cfg)
head(odbdatasets)
to.odb$dataset = odbdataset$id

#person that measured
odbperson = odb_get_persons(params=list(search=&#39;chalom&#39;),odb_cfg=cfg)
to.odb$person = odbperson$id

odb_import_measurements(to.odb,odb_cfg=cfg)</code></pre>
</div>
<div id="categorical-measurements" class="section level2">
<h2>Categorical measurements</h2>
<p>Categories MUST be informed by their ids in the value field. For CATEGORICAL or ORDINAL traits, value may have a single id. For CATEGORICAL_MULTIPLE, may be one or multiple categories ids, that may be a string with ids separated by commas or list with the ids as values.</p>
<pre><code>#get the trait id from the server (check that trait exists)
odbtraits = odb_get_traits(odb_cfg=cfg)
(m = match(c(&quot;specimenFertility&quot;),odbtraits$export_name))

#base line
to.odb = data.frame(trait_id = odbtraits$id[m], date = &#39;2020-07-31&#39;, stringsAsFactors=F)
#the plant was collected with both flowers and fruits
value = c(&quot;Flowers&quot;,&quot;Fruits&quot;)
#get categories for this trait if found
(cats = odbtraits$categories[m][[1]])
#check that your categories are registered for the trait and get their ids
value = cats[match(value,cats$name),&#39;id&#39;]
#make multiple categories ids a string value
value = paste(value,collapse=&quot;,&quot;)

to.odb$value = value

#this links to a specimen
to.odb$object_type = &quot;Voucher&quot;
#get voucher id from API (must be ID). 
#Search for collection number 1234
odbspecs = odb_get_vouchers(params=list(number=&#39;1234&#39;),odb_cfg=cfg)
odbspecs$fullname
to.odb$object_id = odbspecs$id[1]

#get dataset id
odbdatasets = odb_get_datasets(params=list(name=&#39;Collected specimens attributes&#39;),odb_cfg=cfg)
head(odbdatasets)
to.odb$dataset = odbdataset$id

#person that measured
odbperson = odb_get_persons(params=list(search=&#39;chalom&#39;),odb_cfg=cfg)
odbperson
to.odb$person = odbperson$id

odb_import_measurements(to.odb,odb_cfg=cfg)
</code></pre>
</div>
<div id="color-measurements" class="section level2">
<h2>Color measurements</h2>
<p>For color values you have to enter color as their ‘hex RGB strings’ codes. Therefore, any color value is allowed, and it would be easier to use the palette colors in the web interface to enter such measurements. Package <code>gplots</code> allows you to convert color names to hex RGB codes if you want to do it through the API.</p>
<pre><code>#get the trait id from the server (check that trait exists)
odbtraits = odb_get_traits(odb_cfg=cfg)
(m = match(c(&quot;fruitMainColor&quot;),odbtraits$export_name))

#base line
to.odb = data.frame(trait_id = odbtraits$id[m], date = &#39;2020-07-31&#39;, stringsAsFactors=F)

#get color value
library(gplots)
(value =  col2hex(&quot;red&quot;))
to.odb$value = value

#this links to a specimen
to.odb$object_type = &quot;Voucher&quot;
#get voucher id from API (must be ID). Search for collection number 1234
odbspecs = odb_get_vouchers(params=list(number=&#39;1234&#39;),odb_cfg=cfg)
odbspecs$fullname
to.odb$object_id = odbspecs$id[1]

#get dataset id
odbdatasets = odb_get_datasets(params=list(name=&#39;Collected specimens attributes&#39;),odb_cfg=cfg)
head(odbdatasets)
to.odb$dataset = odbdataset$id

#person that measured
odbperson = odb_get_persons(params=list(search=&#39;chalom&#39;),odb_cfg=cfg)
odbperson
to.odb$person = odbperson$id

odb_import_measurements(to.odb,odb_cfg=cfg)
</code></pre>
</div>
<div id="database-link-type-measurements" class="section level2">
<h2>Database link type measurements</h2>
<pre><code>#get the trait id from the server (check that trait exists)
odbtraits = odb_get_traits(odb_cfg=cfg)
(m = match(c(&quot;taxonCount&quot;),odbtraits$export_name))

#base line
to.odb = data.frame(trait_id = odbtraits$id[m], date = &#39;2020-07-31&#39;, stringsAsFactors=F)

#the taxon to link the count value
odbtax = odb_get_taxons(params=list(name=&#39;Euterpe precatoria&#39;),odb_cfg=cfg)
to.odb$link_id = odbtax$id

#now add the count value for this trait type 
#this is optional for this measurement, 
#however, it would make no sense to include such link without a count in this example
to.odb$value = 23 

#a note to clarify the measurement (optional)
to.odb$notes = &#39;First 15min Interval&#39; 

#this measurement will link to a location
to.odb$object_type = &quot;Location&quot;
#get voucher id from API (must be ID). Search for collection number 1234
odblocs = odb_get_vouchers(params=list(name=&#39;Trilha do Pajurá&#39;),odb_cfg=cfg)
odblocs
to.odb$object_id = odblocs$id[1]

#get dataset id
odbdatasets = odb_get_datasets(params=list(name=&#39;Rapid count inventory at some site&#39;),odb_cfg=cfg)
head(odbdatasets)
to.odb$dataset = odbdataset$id

#person that measured
odbperson = odb_get_persons(params=list(search=&#39;chalom&#39;),odb_cfg=cfg)
odbperson
to.odb$person = odbperson$id

odb_import_measurements(to.odb,odb_cfg=cfg)
</code></pre>
</div>
<div id="spectral-measurements" class="section level2">
<h2>Spectral measurements</h2>
<p>Value must be a string with spectrum values separated by “;”</p>
<p>The number of values must match the Trait value_length attribute. So, you may easily check this before importing, getting traits with <code>odb_get_traits(params=list(fields=&#39;all&#39;),cfg)</code></p>
<p>Otherwise, proceed as above.</p>
</div>
<div id="text-measurements" class="section level2">
<h2>Text measurements</h2>
<p>Just add the text to the value field and proceed as above.</p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
